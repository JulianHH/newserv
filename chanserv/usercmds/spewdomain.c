/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: spewdomain
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 1
 * CMDDESC: Spew Mail Domains.
 * CMDFUNC: csu_dospewdomain
 * CMDPROTO: int csu_dospewdomain(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../../lib/irc_string.h"
#include <stdio.h>
#include <string.h>

int csu_dospewdomain(void *source, int cargc, char **cargv) {
  nick *sender=source;
  reguser *rup=getreguserfromnick(sender);
  int i;
  unsigned int count=0;
  maildomain *smdp;
  int limit=0, actlimit=0;

  if (!rup)
    return CMD_ERROR;

  if (cargc < 1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "spewdomain");
    return CMD_ERROR;
  }

  chanservstdmessage(sender, QM_SPEWDOMAINHEADER);
  maildomain *mdp;

  for (i=0;i<MAILDOMAINHASHSIZE;i++) {
    for (mdp=maildomainnametable[i]; mdp; mdp=mdp->nextbyname) {
      if (!match(cargv[0], mdp->name->content)) {
        limit = 0; actlimit=0;
        for(smdp=mdp;smdp;smdp=smdp->parent) {
          if(smdp->limit) {
            limit = smdp->limit; 
            break;           
          }
        }
        for(smdp=mdp;smdp;smdp=smdp->parent) {
          if(smdp->actlimit) {
            actlimit = smdp->actlimit;
            break;
          }
        }
        /***@@@ bug here? i.e. we recurse up to find limit, then check MDHaslimit for current domain only?*/
        chanservsendmessage(sender, "%-19s %-7d %d%s %d%s", mdp->name->content, mdp->count, limit,MDHasLimit(mdp) ? "*":"", actlimit,MDHasActLimit(mdp) ? "*":""); 
        count++;
        if (count >= 2000) {
          chanservstdmessage(sender, QM_TOOMANYRESULTS, 2000, "domains");
          return CMD_ERROR;
        }
      }
    }
  }
  chanservstdmessage(sender, QM_RESULTCOUNT, count, "domain", (count==1)?"":"s");

  return CMD_OK;
}
