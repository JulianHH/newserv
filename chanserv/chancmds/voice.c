/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: voice
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 20
 * CMDDESC: Voices you or other users on channel(s).
 * CMDFUNC: csc_dovoice
 * CMDPROTO: int csc_dovoice(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: VOICE [<channel> [<user1> [<user2> [...]]]]
 * CMDHELP: Grants voice to you on one or more channels, or grants voice to one or more
 * CMDHELP: other users on a particular channel.  This command cannot be used to grant
 * CMDHELP: voice to users who would otherwise be prevented from obtaining voice, e.g.
 * CMDHELP: the quiet (+q) chanlev flag.  Where:
 * CMDHELP: channel - channel to use.  If no channel is specified, you will be granted voice
 * CMDHELP:           on every channel where you have appropriate access and are not already 
 * CMDHELP:           voiced.
 * CMDHELP: user<n> - other users to grant voice to.  Must be specified as the nickname
 * CMDHELP:           of users who are on the named channel.
 * CMDHELP: Voicing yourself requires voice (+v) access on the relevant channels.
 * CMDHELP: Voicing other users requires operator (+o) access on the named channel.  If this 
 * CMDHELP: command is used to voice other users, a notice will be sent to channel operators
 * CMDHELP: on the channel identifying you, unless you have master (+m) access.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dovoice(void *source, int cargc, char **cargv) {
  nick *sender=source, *np;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  regchan *rcp=NULL;
  regchanuser *rcup;
  channel **ca;
  unsigned long *lp;
  int i;
  modechanges changes;
  char buf[512];
  unsigned int bufpos=0,donotice=0;

  if (!rup)
    return CMD_ERROR;
  
  if (cargc==0) {
    /* No args: "voice me on every channel you can */
    ca=sender->channels->content;
    for (i=0;i<sender->channels->cursi;i++) {
      if ((rcp=ca[i]->index->exts[chanservext]) && !CIsSuspended(rcp)) {
	/* It's a Q channel */
	if (!(*(getnumerichandlefromchanhash(ca[i]->users, sender->numeric)) & 
	      (CUMODE_OP|CUMODE_VOICE))) {
	  /* They're not opped or voiced */
	  rcup=findreguseronchannel(rcp, rup);
	  if ((!rcup || !CUIsQuiet(rcup)) && 
	      ((rcup && CUHasVoicePriv(rcup)) ||
	      (CIsVoiceAll(rcp)))) {
	    /* And they have voice priv on the chan (or it's autovoice): 
	     * voice them */
	    localsetmodeinit(&changes, ca[i], chanservnick);
	    localdosetmode_nick(&changes, sender, MC_VOICE);
	    localsetmodeflush(&changes,1);
	  }
	}
      }
    }
    
    chanservstdmessage(sender, QM_DONE);
    return CMD_OK;
  }

  /* If there is at least one arg, the first is a channel */

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_VOICEPRIV, NULL, "voice", 0, 0)))
    return CMD_ERROR;

  if (!cip->channel) {
    chanservstdmessage(sender, QM_EMPTYCHAN, cip->name->content);
    return CMD_ERROR;
  }

  if (cargc==1) {
    /* Only one arg: "voice me" */
    if (!cs_checkaccess(sender, NULL, CA_VOICEPRIV | CA_DEVOICED, cip,
			"voice", 0, 0))
      return CMD_ERROR;

    localsetmodeinit(&changes, cip->channel, chanservnick);
    localdosetmode_nick(&changes, sender, MC_VOICE);
    localsetmodeflush(&changes,1);

    chanservstdmessage(sender, QM_DONE);
    return CMD_OK;
  }

  /* You've got to be an operator to voice other people */
  if (!cs_checkaccess(sender, NULL, CA_OPPRIV, cip, "voice", 0, 0))
    return CMD_ERROR;

  /* You've got to be a master to 'silently' voice other people */
  if (!cs_checkaccess(sender, NULL, CA_MASTERPRIV, cip, "voice", 0, 1))
    donotice=1;

  rcp=cip->exts[chanservext];

  /* Set up the modes */
  localsetmodeinit(&changes, cip->channel, chanservnick);

  for(i=1;i<cargc;i++) {
    if (!(np=getnickbynick(cargv[i]))) {
      chanservstdmessage(sender, QM_UNKNOWNUSER, cargv[i]);
      continue;
    }

    if (!(lp=getnumerichandlefromchanhash(cip->channel->users, np->numeric))) {
      chanservstdmessage(sender, QM_USERNOTONCHAN, np->nick, cip->name->content);
      continue;
    }

    if (*lp & CUMODE_VOICE) {
      chanservstdmessage(sender, QM_USERVOICEDONCHAN, np->nick, cip->name->content);
      continue;
    }
   
    if ((rup=getreguserfromnick(np)) && (rcup=findreguseronchannel(rcp, rup)) && CUIsQuiet(rcup)) {
      chanservstdmessage(sender, QM_CANTVOICE, np->nick, cip->name->content);
      continue;
    }
    
    bufpos+=sprintf(buf+bufpos,"%s%s",bufpos?", ":"",np->nick);
    localdosetmode_nick(&changes, np, MC_VOICE);
  }

  if (donotice && bufpos) {
    sendopnoticetochannel(chanservnick, cip->channel, "%s voiced %s", sender->nick, buf);
  }

  localsetmodeflush(&changes, 1);
  chanservstdmessage(sender, QM_DONE);

  return CMD_OK;
}
