/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: chanflags
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: Shows or changes the flags on a channel.
 * CMDFUNC: csc_dochanflags
 * CMDPROTO: int csc_dochanflags(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dochanflags(void *source, int cargc, char **cargv) {
  regchan *rcp;
  nick *sender=source;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  flag_t oldflags,changemask;
  char flagbuf[20];

  if (cargc<1) {
    chanservstdmessage(sender,QM_NOTENOUGHPARAMS,"chanflags");
    return CMD_ERROR;
  }
  
  if (!(cip=cs_checkaccess(sender, cargv[0], CA_OPPRIV, NULL, 
			   "chanflags", QPRIV_VIEWCHANFLAGS, 0))) 
    return CMD_ERROR;

  rcp=cip->exts[chanservext];

  if (cargc>1) {
    if (!cs_checkaccess(sender, NULL, CA_MASTERPRIV, cip, "chanflags", 
			QPRIV_CHANGECHANFLAGS, 0))
      return CMD_ERROR;

    oldflags=rcp->flags;
    changemask=QCFLAG_USERCONTROL;
    if (UIsDev(rup)) {
      changemask=QCFLAG_ALL;
    }
    setflags(&rcp->flags, changemask, cargv[1], rcflags, REJECT_NONE);

    /* We might need to do things in response to the flag changes.. */
    if (cip->channel) {
      if ((oldflags ^ rcp->flags) & (QCFLAG_JOINED | QCFLAG_SUSPENDED)) {
        chanservjoinchan(cip->channel);
	rcp->status |= (QCSTAT_OPCHECK | QCSTAT_MODECHECK | QCSTAT_BANCHECK);
	rcp->lastbancheck=0;
	cs_timerfunc(cip);
      } else {
        if (CIsEnforce(rcp)) {
	  rcp->lastbancheck=0;
          cs_checkbans(cip->channel);  
	}
    
        if (CIsProtect(rcp) || CIsBitch(rcp) || CIsAutoOp(rcp) || CIsAutoVoice(rcp) || CIsKnownOnly(rcp)) {
	  rcp->status |= QCSTAT_OPCHECK;
	  cs_timerfunc(cip);
	}
      }
    }
    
    if (CIsAutoLimit(rcp) && !(oldflags & QCFLAG_AUTOLIMIT)) {
      rcp->forcemodes |= CHANMODE_LIMIT;
      rcp->denymodes &= ~CHANMODE_LIMIT;
      rcp->limit=0;
      cs_timerfunc(cip);
    }

    if (!CIsAutoLimit(rcp) && (oldflags & QCFLAG_AUTOLIMIT)) {
      rcp->forcemodes &= ~CHANMODE_LIMIT;
      if (cip->channel) 
        cs_checkchanmodes(cip->channel);
    }

    strcpy(flagbuf,printflags(oldflags, rcflags));
    cs_log(sender,"CHANFLAGS %s %s (%s -> %s)",cip->name->content,cargv[1],flagbuf,printflags(rcp->flags,rcflags));
    chanservstdmessage(sender, QM_DONE);
    csdb_updatechannel(rcp);
  }
  
  chanservstdmessage(sender,QM_CURCHANFLAGS,cip->name->content,printflags(rcp->flags, rcflags));
  return CMD_OK;
}
