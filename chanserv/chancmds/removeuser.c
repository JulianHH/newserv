/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: removeuser
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 20
 * CMDDESC: Removes one or more users from a channel.
 * CMDFUNC: csc_doremoveuser
 * CMDPROTO: int csc_doremoveuser(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doremoveuser(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchanuser *rcup;
  regchan *rcp;
  reguser *rup;
  int isowner=0;
  int i;

  if (cargc<2) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "removeuser");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_MASTERPRIV, NULL, "adduser", QPRIV_CHANGECHANLEV, 0)))
    return CMD_ERROR;

  if (cs_checkaccess(sender, NULL, CA_OWNERPRIV, cip, "adduser", QPRIV_CHANGECHANLEV, 1))
    isowner=1;

  rcp=cip->exts[chanservext];

  for (i=1;i<cargc;i++) {
    if (!(rup=findreguser(sender, cargv[i])))
      continue;

    if (!(rcup=findreguseronchannel(rcp, rup))) {
      chanservstdmessage(sender, QM_CHANUSERUNKNOWN, cargv[i], cip->name->content);
      continue;
    }

    if (CUIsOwner(rcup)) {
      chanservstdmessage(sender, QM_CANNOTREMOVEOWNER, cargv[i], cip->name->content);
      continue;
    }

    if (CUIsMaster(rcup) && !isowner && (rup != getreguserfromnick(sender))) {
      chanservstdmessage(sender, QM_CANNOTREMOVEMASTER, cargv[i], cip->name->content);
      continue;
    }
    
    cs_log(sender,"CHANLEV %s #%s -%s (%s -> +)",cip->name->content,rup->username,
	   printflags_noprefix(rcup->flags, rcuflags), printflags(rcup->flags, rcuflags));

    csdb_deletechanuser(rcup);
    delreguserfromchannel(rcp, rup);
  }

  rcp->status |= QCSTAT_OPCHECK;
  cs_timerfunc(cip);

  chanservstdmessage(sender, QM_DONE);

  return CMD_OK;
}
