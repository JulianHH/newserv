/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: chantype
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 2
 * CMDDESC: Shows or changes a channel's type.
 * CMDFUNC: csc_dochantype
 * CMDPROTO: int csc_dochantype(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: chantype <channel> [<channel type>]
 * CMDHELP: Views or changes the channel type for the specified channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dochantype(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchan *rcp;
  int type;

  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "chantype");
    return CMD_ERROR;
  }

  if (!(cip=findchanindex(cargv[0])) || !(rcp=cip->exts[chanservext])) {
    chanservstdmessage(sender, QM_UNKNOWNCHAN, cargv[0]);
    return CMD_ERROR;
  }

  if (cargc>1) {
    /* Set type */
    for (type=CHANTYPES-1;type;type--) {
      if (!ircd_strcmp(chantypes[type]->content, cargv[1]))
	break;
    }
    if (!type) {
      chanservstdmessage(sender, QM_UNKNOWNCHANTYPE, cargv[1]);
      return CMD_ERROR;
    }
    rcp->chantype=type;

    csdb_updatechannel(rcp);
    chanservstdmessage(sender, QM_DONE);
  }

  chanservstdmessage(sender, QM_CHANTYPEIS, cip->name->content, chantypes[rcp->chantype]->content);

  return CMD_OK;
}
