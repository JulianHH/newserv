/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: invite
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 1
 * CMDDESC: Invites you to a channel.
 * CMDFUNC: csc_doinvite
 * CMDPROTO: int csc_doinvite(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: INVITE <channel>
 * CMDHELP: Invites you to the named channel, where:
 * CMDHELP: channel - channel to be invited to.
 * CMDHELP: INVITE requires you to be known (+k) on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doinvite(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;

  /* If no argument supplied, try and invite the user to every channel
   * we can. */
  if (cargc<1) {
    reguser *rup=getreguserfromnick(sender);
    regchanuser *rcup;

    if (!rup)
      return CMD_ERROR;

    for (rcup=rup->knownon;rcup;rcup=rcup->nextbyuser) {
      /* skip empty or suspended channels */
      if (!rcup->chan->index->channel || CIsSuspended(rcup->chan)) {
        continue;
      }
      
      /* skip channels the user is already on */
      if (getnumerichandlefromchanhash(rcup->chan->index->channel->users, sender->numeric)) {
        continue;
      }

      /* skip channels where the user can't do INVITE */
      if (!CUKnown(rcup)) {
        continue;
      }
      
      localinvite(chanservnick, rcup->chan->index->channel, sender);
    }
    
    chanservstdmessage(sender, QM_DONE);
    return CMD_OK;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_KNOWN | CA_OFFCHAN, 
			   NULL, "invite", 0, 0)))
    return CMD_ERROR;

  if (cip->channel) {
    localinvite(chanservnick, cip->channel, sender);
  }
  chanservstdmessage(sender, QM_DONE);
 
  return CMD_OK;
}
