/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: settopic
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: Changes the topic on a channel.
 * CMDFUNC: csc_dosettopic
 * CMDPROTO: int csc_dosettopic(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: SETTOPIC <channel> [<topic>]
 * CMDHELP: Changes the topic on the channel, where:
 * CMDHELP: channel - channel to use
 * CMDHELP: topic   - new topic.  If no topic is set, the stored topic will be reset (this
 * CMDHELP:           feature is useful if some users can no longer see the topic due to a 
 * CMDHELP:           netsplit).
 * CMDHELP: SETTOPIC requires topic (+t) or master (+m) access on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dosettopic(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchan *rcp;

  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "settopic");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_TOPICPRIV, 
			   NULL, "settopic", 0, 0)))
    return CMD_ERROR;

  rcp=cip->exts[chanservext];

  if (cargc>1) {
    if (rcp->topic)
      freesstring(rcp->topic);
    rcp->topic=getsstring(cargv[1],TOPICLEN);
  } 
  
  if (rcp->topic && cip->channel) {
    localsettopic(chanservnick, cip->channel, rcp->topic->content);
  }

  chanservstdmessage(sender, QM_DONE);
  csdb_updatechannel(rcp);
  return CMD_OK;
}
