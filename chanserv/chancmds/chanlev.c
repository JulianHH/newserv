/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: chanlev
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 3
 * CMDDESC: Shows or modifies user access on a channel.
 * CMDFUNC: csc_dochanlev
 * CMDPROTO: int csc_dochanlev(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int compareflags(const void *u1, const void *u2) {
  const regchanuser *r1=*(void **)u1, *r2=*(void **)u2;
  flag_t f1,f2;

  for (f1=QCUFLAG_OWNER;f1;f1>>=1)
    if (r1->flags & f1)
      break;

  for (f2=QCUFLAG_OWNER;f2;f2>>=1)
    if (r2->flags & f2)
      break;

  if (f1==f2) {
    return ircd_strcmp(r1->user->username, r2->user->username);
  } else {
    return f2-f1;
  }
}

int csc_dochanlev(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchan *rcp;
  regchanuser *rcup, *rcuplist;
  regchanuser **rusers;
  reguser *rup=getreguserfromnick(sender), *target;
  char time1[15],time2[15];
  char flagbuf[30];
  struct tm *tmp;
  flag_t flagmask, changemask, flags, oldflags;
  int showtimes=0;
  int donehead=0;
  int i,j;
  int newuser=0;
  int usercount;

  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "chanlev");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_KNOWN,
			   NULL, "chanlev", QPRIV_VIEWFULLCHANLEV, 0)))
    return CMD_ERROR;
  
  rcp=cip->exts[chanservext];
  rcup=findreguseronchannel(rcp, rup);

  /* Set flagmask for +v/+o users (can't see bans etc.) */
  flagmask = (QCUFLAG_OWNER | QCUFLAG_MASTER | QCUFLAG_OP | QCUFLAG_VOICE | QCUFLAG_AUTOVOICE | 
	      QCUFLAG_AUTOOP | QCUFLAG_TOPIC | QCUFLAG_SPAMCON | QCUFLAG_PROTECT | QCUFLAG_KNOWN);
  
  /* If user has +m or above, or helper access, show everything */
  if (cs_privcheck(QPRIV_VIEWFULLCHANLEV, sender) || CUHasMasterPriv(rcup)) {
    flagmask = QCUFLAG_ALL;
    showtimes=1;
  }
  
  if (cargc==1) {
    /* One arg: list chanlev */
    if (cs_privcheck(QPRIV_VIEWFULLCHANLEV, sender)) {
      reguser *founder=NULL, *addedby=NULL;
      addedby=findreguserbyID(rcp->addedby);
      chanservstdmessage(sender, QM_ADDEDBY, addedby ? addedby->username : "(unknown)");
      founder=findreguserbyID(rcp->founder);
      chanservstdmessage(sender, QM_FOUNDER, founder ? founder->username : "(unknown)");
      if (rcp->chantype) {
        chanservstdmessage(sender, QM_CHANTYPE, chantypes[rcp->chantype]->content);
      }
    }

    /* Count users */
    for (i=0,usercount=0;i<REGCHANUSERHASHSIZE;i++)
      for (rcuplist=rcp->regusers[i];rcuplist;rcuplist=rcuplist->nextbychan)
	usercount++;
    
    /* Allocate array */
    rusers=(regchanuser **)malloc(usercount * sizeof(regchanuser *));

    /* Fill array */
    for (j=i=0;i<REGCHANUSERHASHSIZE;i++) {
      for (rcuplist=rcp->regusers[i];rcuplist;rcuplist=rcuplist->nextbychan) {
	if (!(flags=rcuplist->flags & flagmask))
	  continue;
	
	rusers[j++]=rcuplist;
      }
    }

    /* Sort */
    qsort(rusers, j, sizeof(regchanuser *), compareflags);

    /* List */
    for (i=0;i<j;i++) {
      rcuplist=rusers[i];

      if (!(flags=rcuplist->flags & flagmask)) 
	continue;
      
      if (!donehead) {
	chanservstdmessage(sender, QM_CHANLEVHEADER, cip->name->content);
	if (showtimes) 
	  chanservstdmessage(sender, QM_CHANLEVCOLFULL);
	else
	  chanservstdmessage(sender, QM_CHANLEVCOLSHORT);
	donehead=1;
      }
      
      if (showtimes) {
	if (!rcuplist->usetime) {
	  strcpy(time1,"Never");
	} else {
	  tmp=localtime(&(rcuplist->usetime));
	  strftime(time1,15,"%d/%m/%y %H:%M",tmp);
	}
	if (!rcuplist->changetime) {
	  strcpy(time2, "Unknown");
	} else {
	  tmp=localtime(&(rcuplist->changetime));
	  strftime(time2,15,"%d/%m/%y %H:%M",tmp);
	}
	chanservsendmessage(sender, " %-15s %-13s %-14s  %-14s  %s", rcuplist->user->username, 
			    printflags(flags, rcuflags), time1, time2, rcuplist->info?rcuplist->info->content:"");
      } else 
	chanservsendmessage(sender, " %-15s %s", rcuplist->user->username, printflags(flags, rcuflags));
    }
    
    if (donehead) {
      chanservstdmessage(sender, QM_ENDOFLIST);
    } else {
      chanservstdmessage(sender, QM_NOUSERSONCHANLEV, cip->name->content);
    }

    free(rusers);
  } else {
    /* 2 or more args.. relates to one specific user */
    if (!(target=findreguser(sender, cargv[1])))
      return CMD_ERROR; /* If there was an error, findreguser will have sent a message saying why.. */
    
    rcuplist=findreguseronchannel(rcp, target);
    
    if (cargc>2) {
      /* To change chanlev you have to either.. */
      if (!( cs_privcheck(QPRIV_CHANGECHANLEV, sender) ||             /* Have override privilege */
	     (rcup && rcuplist && (rcup==rcuplist) && CUKnown(rcup)) || /* Be manipulting yourself (oo er..) */
	     (rcup && CUHasMasterPriv(rcup) &&                        /* Have +m or +n on the channel */
	      !(rcuplist && CUIsOwner(rcuplist) && !CUIsOwner(rcup))) /* masters can't screw with owners */
	     )) {
	chanservstdmessage(sender, QM_NOACCESSONCHAN, cip->name->content, "chanlev");
	return CMD_ERROR;
      }
      
      if (!rcuplist) {
	rcuplist=getregchanuser();
	rcuplist->user=target;
	rcuplist->chan=rcp;
	rcuplist->flags=0;
	rcuplist->changetime=time(NULL);
	rcuplist->usetime=0;
	rcuplist->info=NULL;
	newuser=1;
      }
      
      if (cs_privcheck(QPRIV_CHANGECHANLEV, sender)) {
	/* Opers are allowed to change everything */
	changemask = QCUFLAG_ALL;
      } else {
	changemask=0;
	
	/* Everyone can change their own flags (except +dqb), and turn +iwj on/off */
	if (rcup==rcuplist) {
	  changemask = (rcup->flags | QCUFLAG_HIDEWELCOME | QCUFLAG_HIDEINFO | QCUFLAG_AUTOINVITE) & 
	              ~(QCUFLAG_BANNED | QCUFLAG_DENY | QCUFLAG_QUIET);
	  flagmask |= (QCUFLAG_HIDEWELCOME | QCUFLAG_HIDEINFO | QCUFLAG_AUTOINVITE);
	}
	
	/* Masters are allowed to manipulate +ovagtbqdpk */
	if (CUHasMasterPriv(rcup))
	  changemask |= ( QCUFLAG_KNOWN | QCUFLAG_OP | QCUFLAG_VOICE | QCUFLAG_AUTOOP | QCUFLAG_AUTOVOICE | 
			  QCUFLAG_TOPIC | QCUFLAG_BANNED | QCUFLAG_QUIET | QCUFLAG_DENY | QCUFLAG_PROTECT);
	
	/* Owners are allowed to manipulate +ms as well */
	if (CUIsOwner(rcup))
	  changemask |= ( QCUFLAG_MASTER | QCUFLAG_SPAMCON );
      }

      oldflags=rcuplist->flags;
      if (setflags(&(rcuplist->flags), changemask, cargv[2], rcuflags, REJECT_UNKNOWN | REJECT_DISALLOWED)) {
	chanservstdmessage(sender, QM_INVALIDCHANLEVCHANGE);
	return CMD_ERROR;
      }

      /* Now fix up some "impossible" combinations.. */
      /* +m can't be any of +qdb */
      if (CUHasMasterPriv(rcuplist))
	rcuplist->flags &= ~(QCUFLAG_BANNED | QCUFLAG_QUIET | QCUFLAG_DENY);
      
      /* +d can't be +o */
      if (CUIsDeny(rcuplist))
	rcuplist->flags &= ~QCUFLAG_OP;

      /* +q can't be +v */
      if (CUIsQuiet(rcuplist))
	rcuplist->flags &= ~QCUFLAG_VOICE;

      /* -o or +p can't be +a */
      if (!CUIsOp(rcuplist) || CUIsProtect(rcuplist))
	rcuplist->flags &= ~QCUFLAG_AUTOOP;
      
      /* +a or -v or +p can't be +g */
      if (!CUIsVoice(rcuplist) || CUIsAutoOp(rcuplist) || CUIsProtect(rcuplist))
	rcuplist->flags &= ~QCUFLAG_AUTOVOICE;

      /* and -ov can't be +p */
      if (!CUIsOp(rcuplist) && !CUIsVoice(rcuplist)) 
      	rcuplist->flags &= ~QCUFLAG_PROTECT;

      /* Check if anything "significant" has changed */
      if ((oldflags ^ rcuplist->flags) & (QCUFLAG_OWNER | QCUFLAG_MASTER | QCUFLAG_OP))
	rcuplist->changetime=time(NULL);

      strcpy(flagbuf,printflags(oldflags,rcuflags));
      cs_log(sender,"CHANLEV %s #%s %s (%s -> %s)",cip->name->content,rcuplist->user->username,cargv[2],
	     flagbuf,printflags(rcuplist->flags,rcuflags));

      /* Now see what we do next */
      if (rcuplist->flags) {
	/* User still valid: update or create */
	if (newuser) {
	  addregusertochannel(rcuplist);
	  csdb_createchanuser(rcuplist);
	} else {
	  csdb_updatechanuser(rcuplist);
	}
      } else {
	/* User has no flags: delete */
	if (!newuser) {
	  csdb_deletechanuser(rcuplist);
	  delreguserfromchannel(rcp, target);
	}
	freeregchanuser(rcuplist);
	rcuplist=NULL;
        for (i=0;i<REGCHANUSERHASHSIZE;i++)
          if (rcp->regusers[i])
            break;
        if (i==REGCHANUSERHASHSIZE) {
	  cs_log(sender,"DELCHAN %s (Cleared chanlev)",cip->name->content);
          cs_removechannel(rcp);	
	}
      }

      /* Say we've done it */
      chanservstdmessage(sender, QM_DONE);
      rcp->status |= QCSTAT_OPCHECK;
      cs_timerfunc(cip);
    }
    
    if (rcuplist && (rcuplist->flags & flagmask)) {
      chanservstdmessage(sender, QM_CHANUSERFLAGS, cargv[1], cip->name->content, 
			 printflags(rcuplist->flags & flagmask, rcuflags));
    } else {
      chanservstdmessage(sender, QM_CHANUSERUNKNOWN, cargv[1], cip->name->content);
    }
  }
  
  return CMD_OK;
}
