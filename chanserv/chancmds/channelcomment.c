/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: channelcomment
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 2
 * CMDDESC: Shows or changes the staff comment for a channel.
 * CMDFUNC: csc_dochannelcomment
 * CMDPROTO: int csc_dochannelcomment(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: channelcomment <channel> [<comment>]
 * CMDHELP: Sets or views a comment for a channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dochannelcomment(void *source, int cargc, char **cargv) {
  nick *sender=source;
  reguser *rup=getreguserfromnick(sender);
  regchan *rcp;
  chanindex *cip;
  char buf[300];
  int bufpos;

  if (!rup)
    return CMD_ERROR;

  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "channelcomment");
    return CMD_ERROR;
  }

  if (!(cip=findchanindex(cargv[0])) || !(rcp=cip->exts[chanservext])) {
    chanservstdmessage(sender, QM_UNKNOWNCHAN, cargv[0]);
    return CMD_ERROR;
  }

  if (cargc>1) {
    if (!ircd_strcmp(cargv[1],"none")) {
      freesstring(rcp->comment);
      rcp->comment=NULL;
    } else {
      if (*cargv[1]=='+') {
	if (rcp->comment) {
	  strcpy(buf,rcp->comment->content);
	  bufpos=rcp->comment->length;
	  buf[bufpos++]=' ';
	} else {
	  bufpos=0;
	}
	strncpy(buf+bufpos, cargv[1]+1, 280-bufpos);
      } else {
	strncpy(buf, cargv[1], 250);
      }
    
      freesstring(rcp->comment);
      rcp->comment=getsstring(buf,250);
    }
    csdb_updatechannel(rcp);
  }
  
  if (rcp->comment) 
    chanservstdmessage(sender, QM_COMMENT, cip->name->content, rcp->comment->content);
  else
    chanservstdmessage(sender, QM_NOCOMMENT, cip->name->content);

  return CMD_OK;
}
